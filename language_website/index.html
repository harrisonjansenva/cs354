<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programming Language Presentation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #000000;
            background: linear-gradient(135deg, #5262ab 0%, #74a3d6 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: rgba(242, 235, 235, 0.95);
            padding: 40px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
        }

        h1 {
            color: #354488;
            font-size: 3em;
            margin-bottom: 10px;
        }

        .tagline {
            color: #d4abab;
            font-size: 1.2em;
            font-style: italic;
        }

        section {
            background: rgba(242, 235, 235, 0.95);
            padding: 30px;
            margin-bottom: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        h2 {
            color: #633a8c;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
            font-size: 2em;
        }

        h3 {
            color: #3e4d8e;
            margin: 20px 0 10px 0;
            font-size: 1.5em;
        }

        .placeholder {
            background: #ffffff;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            margin: 15px 0;
            font-style: italic;
            color: #666;
        }

        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            position: relative;
        }

        .code-block pre {
            margin: 0;
        }

        .code-label {
            background: #626c9d;
            color: white;
            padding: 5px 15px;
            border-radius: 5px;
            font-size: 0.9em;
            display: inline-block;
            margin-bottom: 10px;
        }

        .links-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
            text-overflow: wrap;
        }

        .link-card {
            background: #ffffff;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            transition: all 0.3s ease;
        }

        .link-card:hover {
            border-color: #667eea;
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .link-card h4 {
            color: #764ba2;
            margin-bottom: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th,
        td {
            padding: 15px;
            text-align: left;
            border: 1px solid #ddd;
        }

        th {
            background: #6275cc;
            color: white;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background: #f8f9fa;
        }

        tr:hover {
            background: #e9ecef;
        }

        .install-steps {
            counter-reset: step-counter;
            list-style: none;
            padding: 0;
        }

        .install-steps li {
            counter-increment: step-counter;
            padding: 15px;
            margin: 10px 0;
            background: #f8f4f4;
            border-radius: 8px;
            position: relative;
            padding-left: 60px;
        }

        .install-steps li::before {
            content: counter(step-counter);
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .timeline {
            position: relative;
            padding-left: 40px;
            margin-top: 20px;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 15px;
            top: 0;
            bottom: 0;
            width: 3px;
            background: #667eea;
        }

        .timeline-item {
            position: relative;
            padding: 15px 0 15px 30px;
            margin-bottom: 20px;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -32px;
            top: 20px;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #543376;
            border: 3px solid white;
            box-shadow: 0 0 0 3px #667eea;
        }

        .timeline-year {
            font-weight: bold;
            color: #6071ba;
            font-size: 1.2em;
        }

        img {
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        a {
            display: inline-block;
            overflow-wrap: break-word;
            max-width: 90%;
        }

        ul {
            list-style-type: disc;

            padding-left: 50px;
            list-style-type: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>Coq (Rocq)</h1>
            <p class="tagline">The Interactive Theorem Prover</p>
        </header>

        <section id="description">
            <h2>Description & History</h2>

            <h3>Overview</h3>
            <div class="placeholder">
                Coq (recently renamed <strong>Rocq</strong> in 2025) is a formal proof management system and a
                functional programming language. It provides a rich environment for the interactive development of
                machine-checked formal reasoning.<br><br>
                <strong>Paradigm:</strong> Pure Functional, Dependently Typed, Interactive Theorem Prover.<br>
                <strong>Primary Use Cases:</strong> Modeling programming languages, certifying software and hardware
                (e.g., CompCert compiler), and formalizing mathematics (e.g., 4-Color Theorem, Feit-Thompson
                Theorem).<br>
                <strong>Key Features:</strong>
                <ul>
                    <li><strong>Calculus of Constructions (CoC):</strong> A higher-order logic that serves as the
                        foundation.</li>
                    <li><strong>Gallina:</strong> The native functional specification language of Coq.</li>
                    <li><strong>Extraction:</strong> Ability to extract certified programs to OCaml, Haskell, and
                        Scheme.</li>
                    <li><strong>Tactics:</strong> Powerful tools for constructing complex proofs semi-automatically.
                    </li>
                </ul>
            </div>

            <h3>Historical Timeline</h3>
            <div class="timeline">
                <div class="timeline-item">
                    <div class="timeline-year">1983</div>
                    <div class="placeholder">Development begins at INRIA, based on the Calculus of Constructions (CoC).
                    </div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-year">1989</div>
                    <div class="placeholder">Release of Coq V1 (implied by "development since 1983" and standard
                        history).</div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-year">2005</div>
                    <div class="placeholder">Formal verification of the Four Color Theorem using Coq.</div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-year">2025</div>
                    <div class="placeholder"><strong>Renamed to Rocq:</strong> Honors Inria Rocquencourt (original
                        development site) and the "Roc" bird.</div>
                </div>
            </div>
        </section>

        <section id="resources">
            <h2>Documentation & Resources</h2>

            <div class="links-grid">
                <div class="link-card">
                    <h4>Official Website</h4>
                    <div class="placeholder">
                        Official Home of the Rocq Prover<br>
                        <strong>URL:</strong> <a href="https://rocq-prover.org">https://rocq-prover.org</a>
                    </div>
                </div>

                <div class="link-card">
                    <h4>Official Documentation</h4>
                    <div class="placeholder">
                        Language Manual & Reference<br>
                        <strong>URL:</strong> <a href="https://coq.inria.fr/refman/">https://coq.inria.fr/refman/</a>
                    </div>
                </div>

                <div class="link-card">
                    <h4>Interactive Textbook</h4>
                    <div class="placeholder">
                        Software Foundations (Volume 1: Logical Foundations)<br>
                        <strong>URL:</strong> <a
                            href="https://softwarefoundations.cis.upenn.edu/lf-current/toc.html">https://softwarefoundations.cis.upenn.edu</a>
                    </div>
                </div>

                <div class="link-card">
                    <div class="placeholder">
                        <h4>CompCert C Compiler</h4>
                        C Compiler written in Coq to guarantee program behavior<br>
                        <strong>URL:</strong> <a href="https://compcert.org/doc/">https://compcert.org/doc/</a>
                    </div>
                </div>

            </div>
        </section>

        <section id="installation">
            <h2>Translators & Installation</h2>

            <h3>Available Translators/Compilers</h3>
            <div class="placeholder">
                Coq programs (written in Gallina) can be executed directly within the system using the `Compute`
                command. For high-performance execution, they are typically <strong>extracted</strong> to:
                <ul>
                    <li><strong>OCaml</strong> (Primary target)</li>
                    <li><strong>Haskell</strong></li>
                    <li><strong>Scheme</strong></li>
                </ul>
            </div>

            <h3>Installation Instructions</h3>
            <h4>Windows / macOS / Linux (Native)</h4>
            <ol class="install-steps">
                <li>
                    <div class="placeholder">Download the <strong>Rocq Platform</strong> installer from <a
                            href="https://rocq-prover.org/install">rocq-prover.org/install</a>.</div>
                </li>
                <li>
                    <div class="placeholder">Run the installer. This includes the compiler and the
                        <strong>CoqIDE</strong> editor.
                    </div>
                </li>
                <li>
                    <div class="placeholder">Verify by opening CoqIDE and running a simple command like `Check nat.`
                    </div>
                </li>
            </ol>

            <h4>Containerization (More Advanced Users)</h4>
            <ol class="install-steps">
                <li>
                    <div class="placeholder">Install <strong>Docker</strong> from docker.com.</div>
                </li>
                <li>
                    <div class="placeholder">Install <strong>VSCode</strong> and the "Dev Containers" extension.</div>
                </li>
                <li>
                    <div class="placeholder">Open the Software Foundations folder in VSCode; it will automatically set
                        up the Rocq environment.</div>
                </li>
            </ol>


        </section>

        <section id="compcert">
            <h2>Real-World Application: CompCert</h2>

            <div class="placeholder">
                <strong>CompCert</strong> is a formally verified C compiler developed using Coq, representing one of the
                most significant achievements in software verification. Unlike traditional compilers that may contain
                bugs leading to incorrect optimizations or code generation errors, CompCert comes with a mathematical
                proof that the generated assembly code behaves exactly as specified by the C source code.
            </div>

            <h3>Why CompCert Matters</h3>
            <div class="placeholder">
                <ul>
                    <li><strong>Correctness Guarantee:</strong> CompCert's formal proof ensures that compilation
                        preserves program semantics. If your C program has a certain behavior, the compiled code will
                        have that exact behavior.</li>
                    <li><strong>Safety-Critical Systems:</strong> Used in aerospace, automotive, and medical devices
                        where compiler bugs could have catastrophic consequences.</li>
                    <li><strong>Research Impact:</strong> Demonstrated that large-scale software verification is
                        practical, inspiring similar projects for operating systems, cryptographic implementations, and
                        more.</li>
                </ul>
            </div>

            <h3>Technical Achievement</h3>
            <div class="placeholder">
                The CompCert project consists of over 100,000 lines of Coq proofs covering all compilation passes:
                parsing, optimization, register allocation, and assembly generation. This represents years of work
                proving that each transformation step is semantically equivalent to the original program.
            </div>
        </section>

        <section id="Examples">
            <h2>Language Examples</h2>

            <table>

                <section id="intro-examples">
                    <h2>Introductory Examples</h2>

                    <h3>Variables and Types (Days of Week)</h3>
                    <div class="code-label">Basics.v</div>
                    <div class="code-block">
                        <pre>
Inductive day : Type :=
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
  | sunday.

Definition next_working_day (d:day) : day :=
  match d with
  | monday => tuesday
  | tuesday => wednesday
  | wednesday => thursday
  | thursday => friday
  | friday => monday
  | saturday => monday
  | sunday => monday
  end.

Compute (next_working_day friday).
(* ==> monday : day *)
                </pre>
                    </div>

                    <h4>Build/Run Instructions:</h4>
                    <div class="code-block">
                        <pre>
# Run interactively in CoqIDE or VSCode (Ctrl+Alt+Down)
# Or compile via command line:
rocq compile -Q . LF Basics.v
                </pre>
                    </div>

                    <div class="placeholder">
                        <strong>Expected Output:</strong><br>
                        The `Compute` command outputs: `monday : day`
                    </div>

                    <h3>Recursion (Factorial/Sum)</h3>
                    <div class="code-label">Basics.v</div>
                    <div class="code-block">
                        <pre>
Fixpoint plus (n : nat) (m : nat) : nat :=
  match n with
  | O => m
  | S n' => S (plus n' m)
  end.
                </pre>
                    </div>
                </section>

                <section id="complex-examples">
                    <h2>Complex Example Programs</h2>

                    <h3>Example 1: Inductively Defined Propositions (Collatz)</h3>
                    <div class="placeholder">
                        Demonstrates defining mathematical properties using inductive rules. Here we define the Collatz
                        property: a number eventually reaches 1.
                    </div>
                    <div class="code-label">IndProp.v</div>
                    <div class="code-block">
                        <pre>
Require Import Coq.Arith.Arith.
Inductive Collatz_holds_for : nat -> Prop :=
  | Chf_one : Collatz_holds_for 1
  | Chf_even (n : nat) : Nat.even n = true ->  
      Collatz_holds_for (Nat.div2 n) ->        
      Collatz_holds_for n
  | Chf_odd (n : nat) : Nat.even n = false ->
      Collatz_holds_for ((3 * n) + 1) ->
      Collatz_holds_for n.
                </pre>
                    </div>

                    <h3>Example 2: Abstract Syntax Tree (Imp Language)</h3>
                    <div class="placeholder">
                        Defining the syntax of a simple imperative language ("Imp") as a data structure. This is a
                        common use
                        case: embedding languages within Coq.
                    </div>
                    <div class="code-label">Imp.v</div>
                    <div class="code-block">
                        <pre>
Inductive aexp : Type :=
  | ANum (n : nat)
  | APlus (a1 a2 : aexp)
  | AMinus (a1 a2 : aexp)
  | AMult (a1 a2 : aexp).

Fixpoint aeval (a : aexp) : nat :=
  match a with
  | ANum n => n
  | APlus a1 a2 => (aeval a1) + (aeval a2)
  | AMinus a1 a2 => (aeval a1) - (aeval a2)
  | AMult a1 a2 => (aeval a1) * (aeval a2)
  end.
                </pre>
                    </div>

                    <h3>Example 3: Verifying Optimization (The "Prover" Aspect)</h3>
                    <div class="placeholder">
                        Proving that an optimization (removing "0 + x") is mathematically correct for <em>all</em>
                        possible
                        inputs.
                    </div>
                    <div class="code-label">Imp.v</div>
                    <div class="code-block">
                        <pre>
Fixpoint optimize_0plus (a:aexp) : aexp :=
  match a with
  | ANum n => ANum n
  | APlus (ANum 0) e2 => optimize_0plus e2
  | APlus e1 e2 => APlus (optimize_0plus e1) (optimize_0plus e2)
  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)
  | AMult e1 e2 => AMult (optimize_0plus e1) (optimize_0plus e2)
  end.

Theorem optimize_0plus_sound: forall a,
  aeval (optimize_0plus a) = aeval a.
Proof.
  intros a. induction a.
  - (* Case: ANum *) 
    reflexivity.
    
  - (* Case: APlus *)
    destruct a1.
    + (* Sub-case: a1 is ANum n *)
      destruct n.
      * (* Sub-sub-case: 0 + a2 *)
        simpl.      
        apply IHa2. 
      * (* Sub-sub-case: (S n) + a2 *)
        simpl. rewrite IHa2. reflexivity.
        
    + (* Sub-case: a1 is APlus *)
      simpl in *.         
      rewrite IHa1.  
      rewrite IHa2. 
      reflexivity.
      
    + (* Sub-case: a1 is AMinus *)
      simpl in *. rewrite IHa1. rewrite IHa2. reflexivity.
      
    + (* Sub-case: a1 is AMult *)
      simpl in *. rewrite IHa1. rewrite IHa2. reflexivity.

  - (* Case: AMinus *)
    simpl in *. rewrite IHa1. rewrite IHa2. reflexivity.

  - (* Case: AMult *)
    simpl in *. rewrite IHa1. rewrite IHa2. reflexivity.
Qed.
                </pre>
                    </div>

                </section>
                <section id="complex-examples">
                    <h2>Challenge Problem</h2>

                    <h3>Proving The Correctness of a DFA</h3>
                    <div class="placeholder">
                        Part 1: Introducing the DFA, its states, and its transitions.
                    </div>
                    <div class="code-label">DFA_Proof.v</div>
                    <div class="code-block">
                        <pre>
Require Import List. (* Import standard library for lists *)
Require Import Lia.
Open Scope list_scope.

Inductive sym : Type := O | I.

Inductive state : Type := S0 | S1 | S2.

Definition start_state : state := S0.

Definition is_final (s : state) : Prop := s = S2.

Definition delta (s : state) (a : sym) : state :=
  match s, a with
  | S0, O => S1
  | S0, I => S0
  | S1, O => S1
  | S1, I => S2
  | S2, O => S1
  | S2, I => S0
  end.

Fixpoint delta_star (s : state) (w : list sym) : state :=
  match w with
  | nil => s
  | a :: w' => delta_star (delta s a) w'
  end.
  </pre>
                    </div>
                    <div class="placeholder">
                        Part 2: Prove Soundness: All strings in our alphabet that end in '01' are accepted.
                    </div>
                    <div class="code-block">
                        <pre>
Lemma delta_star_01_is_S2 : forall s, delta_star s (O :: I :: nil) = S2.
Proof.
  destruct s; reflexivity.
Qed.

  
Lemma delta_star_app : forall (q : state) (w1 w2 : list sym),
  delta_star q (w1 ++ w2) = delta_star (delta_star q w1) w2.
Proof.
  intros q w1 w2.
  generalize dependent q.
  induction w1; intros q; simpl.
  - reflexivity.
  - rewrite IHw1. 
  reflexivity.
Qed.

Theorem part1_completeness : forall (prefix : list sym),
  delta_star start_state (prefix ++ (O :: (I :: nil))) = S2.
Proof.
  intros prefix.
  rewrite delta_star_app.
  apply delta_star_01_is_S2.
Qed.

                </pre>
                    </div>
                    <div class="placeholder">
                        Part 3: Proving that all strings that are accepted are accepted because they end in '01'.
                    </div>
                    <div class="code-label">DFA_Proof.v</div>
                    <div class="code-block">
                        <pre>
Lemma ends_with_01 :
  forall w,
    delta_star start_state w = S2 ->
    exists alpha, w = alpha ++ (O :: I :: nil).
Proof.
  intros w H.
  destruct w as [ | a w1 ].
  - (* Case w is empty *)
    simpl in H. discriminate.

  - (* Case w is non empty *)
    destruct w1 as [ | b w2 ].
    + (* Case w is length 1 *)
      simpl in H. destruct a; discriminate.

    + (* Case w has length >= 2 *)
      (* We look at the reversed list to easily peel off the last items *)
      destruct (rev (a :: b :: w2)) as [ | y r ] eqn:Hr.
      
      (* --- Sub-proof 1: Reversed list cannot be empty --- *)
      * exfalso.
        assert (L: length (rev (a :: b :: w2)) = length (@nil sym)).
        { rewrite Hr. reflexivity. }
        rewrite rev_length in L. simpl in L. discriminate.

      (* --- Sub-proof 2: Reversed list has items --- *)
      * destruct r as [ | x r' ].
        (* Case: Reversed list has only 1 item (Impossible for length >= 2) *)
        { 
          assert (L: length (rev (a :: b :: w2)) = length (y :: nil)).
          { rewrite Hr. reflexivity. }
          rewrite rev_length in L. simpl in L. lia.
        }
        
        (* Case: The list has at least 2 items (x and y) *)
        (* This effectively means w ends in ...xy *)
        
        (* 1. Reconstruct w in terms of x and y *)
        (* If rev w = y :: x :: r', then w = rev r' ++ [x; y] *)
       (* 1. Reconstruct w in terms of x and y *)
        assert (H_struct: a :: b :: w2 = rev r' ++ (x :: y :: nil)).
        {
          assert (Hrev_eq: rev (a :: b :: w2) = y :: x :: r'). { apply Hr. }
          
          apply f_equal with (f := @rev sym) in Hrev_eq.
          
          rewrite rev_involutive in Hrev_eq.
          rewrite Hrev_eq.
          simpl.
          rewrite <- app_assoc. 
          reflexivity.
        }

        (* 2. Plug this structure back into the main hypothesis H *)
        rewrite H_struct in H.
        rewrite delta_star_app in H.
        simpl in H.
        
        (* 3. Analyze the last two transitions *)
        (* We know delta_star ( ... ) ends in S2. *)
        (* Let's see which inputs x, y could possibly result in S2 *)
        destruct x, y.
        
        (* Case x=O, y=O (Ends in 00) *)
        (* delta(delta q O) O always goes to S1. S1 <> S2. *)
        { 
           destruct (delta_star start_state (rev r')); simpl in H; discriminate.
        }

        (* Case x=O, y=I (Ends in 01) -> THIS IS THE WINNER *)
        {
           exists (rev r').
           apply H_struct.
        }

        (* Case x=I, y=O (Ends in 10) *)
        (* delta(delta q I) O always goes to S1. S1 <> S2. *)
        {
           destruct (delta_star start_state (rev r')); simpl in H; discriminate.
        }

        (* Case x=I, y=I (Ends in 11) *)
        (* With our NEW delta, this goes to S0. S0 <> S2. *)
        {
           (* We must check the previous state q to be sure *)
           destruct (delta_star start_state (rev r')); simpl in H.
           - discriminate. (* S0 -> S0 -> S0 *)
           - discriminate. (* S1 -> S2 -> S0 (Using the fixed delta!) *)
           - discriminate. (* S2 -> S0 -> S0 *)
        }
Qed.
                            </pre>
                    </div>

                </section>

                <section id="comparison">
                    <h2>Language Comparison</h2>

                    <table>
                        <thead>
                            <tr>
                                <th>Feature/Characteristic</th>
                                <th>Coq (Rocq)</th>
                                <th>Haskell</th>
                                <th>Java</th>
                                <th>Python</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Paradigm</strong></td>
                                <td>Proof Assistant / Pure Functional</td>
                                <td>Pure Functional</td>
                                <td>Object-Oriented</td>
                                <td>Multi-paradigm</td>
                            </tr>
                            <tr>
                                <td><strong>Typing</strong></td>
                                <td>Static, Dependently Typed</td>
                                <td>Static, Strong</td>
                                <td>Static, Strong</td>
                                <td>Dynamic</td>
                            </tr>
                            <tr>
                                <td><strong>Memory Management</strong></td>
                                <td>Extraction (GC via OCaml/Haskell)</td>
                                <td>Garbage Collection</td>
                                <td>Garbage Collection</td>
                                <td>Garbage Collection</td>
                            </tr>
                            <tr>
                                <td><strong>Compilation</strong></td>
                                <td>Bytecode / Transpilation</td>
                                <td>Compiled (GHC)</td>
                                <td>Bytecode (JVM)</td>
                                <td>Interpreted</td>
                            </tr>
                            <tr>
                                <td><strong>Concurrency</strong></td>
                                <td>Via extraction (simpler behavior)</td>
                                <td>Strong (STM, Green threads)</td>
                                <td>Threads / Locks</td>
                                <td>GIL limited</td>
                            </tr>
                            <tr>
                                <td><strong>Performance</strong></td>
                                <td>High (via Extraction)</td>
                                <td>High</td>
                                <td>High</td>
                                <td>Low/Medium</td>
                            </tr>
                            <tr>
                                <td><strong>Primary Use Cases</strong></td>
                                <td>Formal Verification, Math Proofs</td>
                                <td>Systems, Web, Data</td>
                                <td>Enterprise, Web, Mobile</td>
                                <td>Data Science, Web, Scripting</td>
                            </tr>
                        </tbody>
                    </table>
                </section>
    </div>
</body>

</html>