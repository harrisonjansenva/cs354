use std::collections::HashSet;
use std::fmt;

/// A term in lambda calculus is generated by this grammar:
/// Term :
///        identifier
///        | "\" <identifier> "." <Term>
///        | "(" <Term> <Term> ")"
///
/// This data type is the syntax tree for a lambda calculus term.
#[derive(Clone, Debug)]
pub enum Term {
    Var(String),
    Lambda(String, Box<Term>),
    Application(Box<Term>, Box<Term>),
}

/// Implements the Display trait to pretty print the term.
impl fmt::Display for Term {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Term::Var(str) => write!(f, "{}", str),
            Term::Lambda(ident, body) => write!(f, "λ{}.{}", ident, body),
            Term::Application(t1, t2) => write!(f, "({} {})", t1, t2),
        }
    }
}

/// Returns a unique version of `name` that is not used by any other
/// variable in `all_vars`.
fn fresh_name(name: &str, all_vars: &HashSet<String>) -> String {
    let mut new_name: String = name.to_string();
    let mut count: u64 = 0;
    while all_vars.contains(&new_name) {
        new_name = name.to_string() + "_" + &count.to_string();
        count += 1;
    }
    return new_name;
}

impl Term {
    /// Returns the free variables that appear in this Term.  A
    /// variable is free if it does not appear in the bound_vars set.
    /// # Examples
    /// (these are not valid Rust syntax -- only to illustrate the idea!):
    ///   `x`.free_variables({y}) = {x}
    ///   `\x.y`.free_variables({}) = {y} `\x.x`.free_variables({}) = {}
    pub fn free_variables(&self, bound_vars: &mut HashSet<String>) -> HashSet<String> {
        let mut result = HashSet::new();
        match self {
            Term::Var(symb) => {
                if !bound_vars.contains(symb) {
                    result.insert(symb.to_string());
                }
            }
            Term::Lambda(param, body) => {
                bound_vars.insert(param.to_string());
                result.extend(body.free_variables(bound_vars));
                bound_vars.remove(param);
            }
            Term::Application(f, t) => {
                result.extend(f.free_variables(bound_vars));
                result.extend(t.free_variables(bound_vars));
            }
        }
        return result;
    }

    /// Returns all the variables that appear inside of this term.
    pub fn all_variables(&self) -> HashSet<String> {
        let mut result = HashSet::new();
        match self {
            Term::Var(symb) => {
                result.insert(symb.to_string());
            }
            Term::Lambda(param, body) => {
                result.insert(param.to_string());
                result.extend(body.all_variables());
            }
            Term::Application(f, t) => {
                result.extend(f.all_variables());
                result.extend(t.all_variables());
            }
        }
        return result;
    }

    /// Substitutes replacement for var throughout this term.
    /// Performs alpha conversion as necessary.
    pub fn perform_substitution(&self, var: &str, replacement: &Term) -> Term {
        match self {
            Term::Var(symb) => {
                if symb == var {
                    replacement.clone()
                } else {
                    self.clone()
                }
            }
            Term::Application(f, body) => Term::Application(
                Box::new(f.perform_substitution(var, replacement)),
                Box::new(body.perform_substitution(var, replacement)),
            ),
            Term::Lambda(param, body) => {
                let mut bound_vars = HashSet::<String>::new();
                let free_vars = replacement.free_variables(&mut bound_vars);
                if param == var {
                    self.clone()
                } else if free_vars.contains(param) {
                    let mut vars: HashSet<String> = self.all_variables();
                    vars.extend(replacement.all_variables());

                    let fresh_param = fresh_name(param, &vars);
                    let renamed_body =
                        body.perform_substitution(param, &Term::Var(fresh_param.to_string()));
                    Term::Lambda(
                        fresh_param,
                        Box::new(renamed_body.perform_substitution(var, replacement)),
                    )
                } else {
                    Term::Lambda(
                        param.to_string(),
                        Box::new(body.perform_substitution(var, replacement)),
                    )
                }
            }
        }
    }

    /// Performs normal-order reduction.
    pub fn normal_order_reduction(&self) -> Term {
        todo!("Implement this.")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_impl_display() {
        let var = Term::Var("x".to_string());
        assert_eq!(format!("{}", var), "x");

        let lambda = Term::Lambda("x".to_string(), Box::new(Term::Var("x".to_string())));
        assert_eq!(format!("{}", lambda), "λx.x");

        let app = Term::Application(
            Box::new(Term::Var("f".to_string())),
            Box::new(Term::Var("x".to_string())),
        );
        assert_eq!(format!("{}", app), "(f x)");

        let nested = Term::Application(
            Box::new(Term::Lambda(
                "x".to_string(),
                Box::new(Term::Var("x".to_string())),
            )),
            Box::new(Term::Var("y".to_string())),
        );
        assert_eq!(format!("{}", nested), "(λx.x y)");
    }

    #[test]
    fn test_fresh_name() {
        let empty_set = HashSet::new();
        assert_eq!(fresh_name("x", &empty_set), "x");

        let mut vars = HashSet::new();
        vars.insert("y".to_string());
        assert_eq!(fresh_name("x", &vars), "x");

        // Test with name in set - should return an unused name.
        vars.insert("x".to_string());
        assert!(!vars.contains(&fresh_name("x", &vars)));

        vars.insert("x_0".to_string());
        vars.insert("x_1".to_string());
        assert!(!vars.contains(&fresh_name("x", &vars)));
    }

    #[test]
    fn test_free_variables() {
        let var = Term::Var("x".to_string());
        let mut bound = HashSet::new();
        assert_eq!(
            var.free_variables(&mut bound),
            ["x"].iter().map(|s| s.to_string()).collect()
        );

        bound.insert("x".to_string());
        assert_eq!(var.free_variables(&mut bound), HashSet::new());

        let lambda = Term::Lambda("x".to_string(), Box::new(Term::Var("y".to_string())));
        let mut bound = HashSet::new();
        assert_eq!(
            lambda.free_variables(&mut bound),
            ["y"].iter().map(|s| s.to_string()).collect()
        );

        let lambda2 = Term::Lambda("x".to_string(), Box::new(Term::Var("x".to_string())));
        let mut bound = HashSet::new();
        assert_eq!(lambda2.free_variables(&mut bound), HashSet::new());

        let app = Term::Application(
            Box::new(Term::Var("f".to_string())),
            Box::new(Term::Var("x".to_string())),
        );
        let mut bound = HashSet::new();
        assert_eq!(
            app.free_variables(&mut bound),
            ["f", "x"].iter().map(|s| s.to_string()).collect()
        );
    }

    #[test]
    fn test_all_variables() {
        let var = Term::Var("x".to_string());
        assert_eq!(
            var.all_variables(),
            ["x"].iter().map(|s| s.to_string()).collect()
        );

        let lambda = Term::Lambda("x".to_string(), Box::new(Term::Var("y".to_string())));
        assert_eq!(
            lambda.all_variables(),
            ["x", "y"].iter().map(|s| s.to_string()).collect()
        );

        let lambda2 = Term::Lambda("x".to_string(), Box::new(Term::Var("x".to_string())));
        assert_eq!(
            lambda2.all_variables(),
            ["x"].iter().map(|s| s.to_string()).collect()
        );

        let app = Term::Application(
            Box::new(Term::Var("f".to_string())),
            Box::new(Term::Var("x".to_string())),
        );
        assert_eq!(
            app.all_variables(),
            ["f", "x"].iter().map(|s| s.to_string()).collect()
        );

        let nested = Term::Application(
            Box::new(Term::Lambda(
                "x".to_string(),
                Box::new(Term::Var("x".to_string())),
            )),
            Box::new(Term::Var("y".to_string())),
        );
        assert_eq!(
            nested.all_variables(),
            ["x", "y"].iter().map(|s| s.to_string()).collect()
        );
    }

    #[test]
    fn test_perform_substitution() {
        let var = Term::Var("x".to_string());
        let replacement = Term::Var("y".to_string());
        let result = var.perform_substitution("x", &replacement);
        assert_eq!(format!("{}", result), "y");

        let result = var.perform_substitution("z", &replacement);
        assert_eq!(format!("{}", result), "x");

        let app = Term::Application(
            Box::new(Term::Var("x".to_string())),
            Box::new(Term::Var("y".to_string())),
        );
        let result = app.perform_substitution("x", &Term::Var("z".to_string()));
        assert_eq!(format!("{}", result), "(z y)");

        let lambda = Term::Lambda("x".to_string(), Box::new(Term::Var("x".to_string())));
        let result = lambda.perform_substitution("x", &Term::Var("y".to_string()));
        assert_eq!(format!("{}", result), "λx.x");

        let lambda = Term::Lambda("x".to_string(), Box::new(Term::Var("y".to_string())));
        let result = lambda.perform_substitution("y", &Term::Var("z".to_string()));
        assert_eq!(format!("{}", result), "λx.z");

        let lambda = Term::Lambda("y".to_string(), Box::new(Term::Var("x".to_string())));
        let replacement = Term::Var("y".to_string());
        let result = lambda.perform_substitution("x", &replacement);

        assert!(format!("{}", result).starts_with("λy_"));
        assert!(format!("{}", result).contains(".y"));
    }

    #[test]
    fn test_normal_order_reduction() {
        todo!("Write this test!");
    }
}
